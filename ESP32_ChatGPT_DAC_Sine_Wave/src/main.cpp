/*
  This code includes the esp_system.h and driver/dac.h header files, which contain the 
  necessary definitions and declarations for the DAC functions.

  The code defines a number of constants:

  DAC_CHANNEL specifies the DAC channel to use. The ESP32 has two DAC channels, DAC1 and DAC2.
  DAC_BIT_DEPTH specifies the bit depth of the DAC. The DAC on the ESP32 has a fixed bit depth of 8 bits.
  MAX_AMPLITUDE specifies the amplitude of the waveform. It is set to 1/2 the maximum value of the DAC's bit depth.
  FREQUENCY specifies the frequency of the square wave in Hz.
  In the setup function, the DAC is initialized by calling the dac_output_enable function with the specified DAC channel.

  In the loop function, a square wave is generated by alternating between setting the DAC output to the maximum value and setting it to 0. The dac_output_voltage function is used to set the DAC output voltage, and the vTaskDelay function is used to pause the task for a specified number of milliseconds.

  This code will generate a square wave with the specified frequency and amplitude on the DAC output. You can use an oscilloscope or other equipment to measure the waveform.
*/

#include <Arduino.h>
#include "esp_system.h"
#include "driver/dac.h"
#include <stdio.h>

#define FREQUENCY 44000
#define DAC_CHANNEL DAC_CHANNEL_1
#define DAC_MAX_VALUE 255
#define DAC_BIT_DEPTH 8
#define MAX_AMPLITUDE (1 << (DAC_BIT_DEPTH - 1))  //keeps the output amplitude 50% below the maximum voltage 

hw_timer_t * timer = NULL;

// Flag to track the state of the square wave
bool square_wave_state = false;

void IRAM_ATTR onTimer() {
  if (square_wave_state) {
    dac_output_voltage(DAC_CHANNEL, MAX_AMPLITUDE);
  } else {
    dac_output_voltage(DAC_CHANNEL, 0);
  }

  // Toggle the square wave state
  square_wave_state = !square_wave_state;
}

void setup() {
  printf("---------------- setup() called -----------------");
  dac_output_enable(DAC_CHANNEL);

  timer = timerBegin(0, 80, true);
  timerAttachInterrupt(timer, &onTimer, true);
  //we divide frequency by 2 below, since onTimer() must be called twice per cycle
  timerAlarmWrite(timer, 1000000 / FREQUENCY/2, true);
  timerAlarmEnable(timer);
}

void loop() {
  // Do nothing
}



/*

void setup() {
  Serial.begin(115200);
  Serial.println("------------- AMPLITUDE & DAC_MAX_VALUE/2-------------");
  Serial.println(MAX_AMPLITUDE);
  Serial.println(DAC_MAX_VALUE/2);
  Serial.println("-------------------------------------");

  dac_output_enable(DAC_CHANNEL);
}

//ramp waveform
void generateRamp() {
  for (int i = 0; i < MAX_AMPLITUDE; i++) {
    dac_output_voltage(DAC_CHANNEL, i);
  }
}

void generateSquare(){
  // Generate a square wave
  int frequency = FREQUENCY/2;
  for (int i = 0; i < frequency; i++) {
    dac_output_voltage(DAC_CHANNEL, MAX_AMPLITUDE);
    vTaskDelay(1);
    dac_output_voltage(DAC_CHANNEL, 0);
    vTaskDelay(1);
  }
}

//sinusoidal waveform
//This code will calculate the sine value at each step using the time t, 
//which ranges from 0 to 1 over the course of the loop, and then output the DAC value using the dac_output_voltage function.
void generateSine() {
  for (int i = 0; i < 1000; i++) {
    float t = i / 1000.0;
    int sin_val = (int)(DAC_MAX_VALUE/2 * (1.0 + sin(2 * M_PI * t)));
    dac_output_voltage(DAC_CHANNEL, sin_val);
    delay(1);
  }
}

void loop() {
  generateSquare();
}



*/
